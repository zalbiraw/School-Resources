/**
 * QuadTree is a class that takes in a QuadNode object and splits recursively until it reaches the maximum level
 * of splits. While splitting the program also creates a QuadTree with QuadNode elements. Furthermore, the class has
 * two classes that are implemented by the Main.java class provided by the professor and displays the visual solution
 * generated by the class.
 * 
 * @author Zaid Albirawi
 * Student #: 250626065
 * Mail: zalbiraw@uwo.ca
 * Course #: CS1027-001
 * Assignment #4
 * 007 Thursday, 12:30 Michael Aro maro@uwo.ca
 * 
 * @version 1.0 11/04/2013
 */
public class QuadTree 
{
	/**
     * Creates all the instance variables.
     */
	
	/**
     * Creates 6 double variables that will hold the color thresholders and sigmas of the colors.
     */
	double sigmaRed, sigmaGreen, sigmaBlue, redT, greenT, blueT;
	/**
     * Creates 2 integer variables that will keep track of the depth level for the splitting.
     */
	int maxLevel, level;
	/**
     * Creates 4 temp QuadNode objects that will hold the value of the temp QuadNodes.
     */
	QuadNode northEast, northWest, southEast, southWest;
	/**
     * Creates a pic that will hold the value of the picture provided.
     */
	MyPicture pic;
	/**
     * Creates 3 integers that will hold the values of the sidelength of the QuadNode and the x and y values
     * of that node.
     */
	int sideLength, x, y;
	
	/**
	  * The constructor of the class QuadTree that will initialize the value of the instance variables and 
	  * run the split method.
	  * 
	  * @param		pic			a MyPicture object that will hold the value of the picture being split.
	  * @param		root		a QuadNode that holds the values of the pic and that will be split into
	  * 						smaller QuadNodes and inserted into a QuadTree.
	  * @param		maxLevel	an int that will hold the number of the max depth level for splitting 
	  * @param		RedT		a double that will hold the value of red thresholder.
	  * @param		GreenT		a double that will hold the value of green thresholder.
	  * @param		BlueT		a double that will hold the value of blue thresholder.
	  * 
	  */
	public QuadTree (MyPicture pic,QuadNode root,int maxLevel,double RedT,double GreenT,double BlueT)
	{
		/**
	     * Initializes all the values of the instance values.
	     */
		this.redT=RedT;
		this.greenT=GreenT;
		this.blueT=BlueT;
		this.maxLevel=maxLevel;
		this.pic=pic;
		
		/**
	     * calls the split method.
	     */
		split(root);
	}
	
	/**
	  * A method that will split the QuadNode recursively depending on the result from the method isHomogeneous
	  * 
	  * @param		node		a QuadNode object that contains a QuadNode that will be split into 4 different QuadNodes.
	  */
	public void split(QuadNode node)
	{
		/**
	     * Initializes the values of the sideLength of the node and its x and y values. 
	     */
		sideLength=node.getSideLength()/2;
		x=node.getX();y=node.getY();
		
		/**
	     * keeps track of the depth level and sets the depth level in the node.
	     */
		node.setLevel(level++);
		
		/**
	     * Initializes the northWest node and sets its parent and sets it as a NorthWest node for the main parent node.
	     */
		northWest = new QuadNode (pic, x, y, sideLength,level,pic.simpleStatistics(x, y, sideLength));
		northWest.setParent(node);node.setNorthWest(northWest);
		
		/**
	     * Initializes the northEast node and sets its parent and sets it as a northEast node for the main parent node.
	     */
		northEast = new QuadNode (pic, x+sideLength, y, sideLength,level,pic.simpleStatistics(x+sideLength, y, sideLength));
		northEast.setParent(node);node.setNorthEast(northEast);
		
		/**
	     * Initializes the southWest node and sets its parent and sets it as a southWest node for the main parent node.
	     */
		southWest = new QuadNode (pic, x, y+sideLength, sideLength,level,pic.simpleStatistics(x, y+sideLength, sideLength));
		southWest.setParent(node);node.setSouthWest(southWest);
		
		/**
	     * Initializes the southEast node and sets its parent and sets it as a southEast node for the main parent node.
	     */
		southEast = new QuadNode (pic, x+sideLength, y+sideLength, sideLength,level,pic.simpleStatistics(x+sideLength, y+sideLength, sideLength));
		southEast.setParent(node);node.setSouthEast(southEast);
		
		/**
	     * 4 if statements that checks if the node isHomogeneous, if not then it splits it.
	     */
		if (!isHomogeneous(node.getNorthWest()))
			split(node.getNorthWest());
		if (!isHomogeneous(node.getNorthEast()))
			split(node.getNorthEast());
		if (!isHomogeneous(node.getSouthWest()))
			split(node.getSouthWest());
		if (!isHomogeneous(node.getSouthEast()))
			split(node.getSouthEast());
		/**
	     * keeps track of the level depth
	     */
		level--;
	}
	
	/**
	  * A method that will determine if the node is homogeneous
	  * 
	  * @param		node		a QuadNode object that contains a QuadNode that will be checked if it is homogeneous
	  * 
	  * @return 				returns a boolean. True if the QuadNode is homogeneous, false if not.
	  */
	public boolean isHomogeneous(QuadNode node)
	{
		/**
	     * Initializes the double values of the sigmaRed, sigmaGreen, and sigmaBlue.
	     */
		sigmaRed=node.getSigmaRed();
		sigmaGreen=node.getSigmaGreen();
		sigmaBlue=node.getSigmaBlue();
		
		/**
	     * an If statement to determine if the QuadNode is homogeneous
	     */
		if ((sigmaRed<=redT&&sigmaGreen<=greenT&&sigmaBlue<=blueT)||level==maxLevel)
			return true;
		return false;
	}
	
	/**
	  * A method that will determine if the node is a leaf.
	  * 
	  * @param		node		a QuadNode object that will be tested if it has any children.
	  * 
	  * @return 				returns a boolean. True if the QuadNode is a leaf, false if not.
	  */
	public boolean isLeaf(QuadNode node)
	{
		if (node.getNorthWest()==null)
			return true;
		return false;
	}
	
	/**
	  * A method that will add the leaf QuadNodes to a queue in preordered way.
	  * 
	  * @param		node		a QuadNode that will have the value of the root node.
	  * @param		queue		a LinkedQueue<QuadNode> queue that will contain the leaf QuadNodes.
	  * 
	  * @return 				returns a LinkedQueue<QuadNode> that contains all the leaf QuadNodes.
	  */
	public LinkedQueue<QuadNode> preorder (QuadNode node, LinkedQueue<QuadNode> queue)
	{
		 if (node != null)
		 {
			 /**
			   * checks if the node is a leaf and adds to the queue.
			   */
			 if (isLeaf(node))
				 queue.enqueue(node);
			 /**
			   * recursively goes through the queue.
			   */
			 preorder(node.getNorthWest(), queue);
			 preorder(node.getNorthEast(), queue);
			 preorder(node.getSouthWest(), queue);
			 preorder(node.getSouthEast(), queue);
		 }
		 /**
		   * returns the a queue filled with all the leafs
		   */
		 return queue;
	}
	
	/**
	  * A method that will activate the drawWhiteSquare method in the MyPicture class to draw a picture with white squares.
	  * 
	  * @param		pic			a MyPicture object picture that will contain the picture
	  * @param		queue		a LinkedQueue<QuadNode> queue that will contain the leaf QuadNodes.
	  */
	public void drawSegmentation (MyPicture pic, LinkedQueue<QuadNode> queue)
	{
		int i=0;
		QuadNode node;
		/**
		  * a while loop that will draw the white squares.
		  */
		while (i<queue.size())
		{
			/**
			  * enqueue and dequeues the nodes.
			  */
			node=queue.dequeue();queue.enqueue(node);
			pic.drawWhiteSquare(node.getX(), node.getY(), node.getSideLength());i++;
		}	
	}

	/**
	  * A method that will activate the paintSquares method in the MyPicture class to draw a picture with painted squares.
	  * 
	  * @param		pic			a MyPicture object picture that will contain the picture
	  * @param		queue		a LinkedQueue<QuadNode> queue that will contain the leaf QuadNodes.
	  */
	public void paintSquares(MyPicture pic2, LinkedQueue<QuadNode> queue) 
	{
		int i=0;
		QuadNode node;
		/**
		  * a while loop that will draw the new squares.
		  */
		while (i<queue.size())
		{
			/**
			  * enqueue and dequeues the nodes.
			  */
			node=queue.dequeue();queue.enqueue(node);
			pic2.paintSegment(node.getX(), node.getY(), node.getSideLength(), node.getMeanRed(), node.getMeanGreen(), node.getMeanBlue());i++;
		}
	}
}